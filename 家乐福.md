## 家乐福

### IOS 手机中 input 框中粘贴复制触发不了 Keyup 事件：

解决方法：

1. change 事件
2. input 事件



### JS 对 iframe 进行操作

这里我们需要使用两个API：

1. contentWindow--获取子页面window
2. postMessage--跨域情况下向子页面发送信息

```javascript
// 父页面
window.onload = function () {
    var frame = document.getElementById('iframeID').contentWindow;
    var message = {
        parentOrigin: window.origin,
        msg: '收到请回复'
    }
    // 向子页面发送信息
    frame.postMessage(JSON.stringify(message), 'http://子页面')
    // 接收从子页面传递过来的信息
    window.addEventListener('message', receiveMessage, false);
}

var receiveMessage = function (event) {
    if (event.origin !== '子页面') return;
    $('iframeID').attr('height', event.data + 50 + 'px')
}

// 子页面
// 接收从父页面传递过来的信息
window.addEventListener('message', function (event) {
    const data = JSON.parse(event.data)
    if (event.origin !== data.parentOrigin) return
    // 向父页面传递自身的滚动高度
    // event.source.postMessage(document.body.scrollHeight, event.origin)
    /**
    	这里最好是用 top,因为用 window 或者用 event.source 的话，会直接获取 iframe 页面的 window ，这样的话就会报错：failed to execude 'postMessage' on 'DOMWindow'，即因为不同源策略而报错了，用 top 的话，会直接获取 iframe 的 parent，即父页面，这样就可以避免不同源错误
    */
    top.postMessage(document.body.scrollHeight, event.origin)
}, false)
```

## iframe 子页面高度

首先我们想到的是在父页面不设置 iframe 高度的情况下，先获取到子页面的高度，然后子页面将获取到的高度传递给父级页面，父级页面在拿到子页面传来的值后，动态赋值给 iframe 的 height 属性，从而实现 iframe 的高度自适应。

1. 有 A、B 两个页面，A页面嵌套B页面
2. 首先，在A页面使用 iframe 的 postMessage 方法，传递消息给B页面
3. B页面监听到对应的事件之后，在回调函数中获取当前页面的 scrollHeight，然后再使用 top.postMessage方法将值传给父页面
4. 父页面同样监听对应的事件，并从返回值中拿到高度，最后赋值给 iframe 的 height 属性
5. 最后 remove 调监听的事件，防止多次注册监听

A.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #iframe {
      width: 100%;
      height: 100%;
      overflow: scroll;
    }
  </style>
</head>
<body>
  <iframe id="iframe" src="./B.html" frameborder="0" scrolling="no"></iframe>
</body>
</html>
<script>
  
  const iframe = document.getElementById('iframe');
  window.onload = function () {
    const url = 'B.html'
    setTimeout(() => {
      const message = {
        parentOrigin: window.origin,
        msg: "收到请回复"
      }
      iframe.contentWindow.postMessage(JSON.stringify(message), "http://127.0.0.1:5500/B.html");
    }, 2000)
    window.addEventListener("message", receiveMessage, false);
  }

  var receiveMessage = function (event) {
    iframe.style.height = event.data + 'px';
    window.removeEventListener('message')
  }
</script>
```

然后在B.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #app {
      height: 3000px;
      background-color: pink;
    }
  </style>
</head>
<body>
  <div id="app"></div>
</body>
</html>
<script>
window.addEventListener('message', function (e) {
  const childPageHeight = document.documentElement.scrollHeight;
  top.postMessage(childPageHeight, 'http://127.0.0.1:5500/A.html')
})
</script>
```

缺点：页面未加载完成前，iframe 部分的高度始终是默认高度，只有当页面加载后，才能重新赋值高度。