# 药明康德

### sass 配置全局变量

1. 在 vue.config.js 中配置 css 配置项：

```javascript
module.exports = {
    css: {
        loaderOptions: {
            scss: {
                prependData: `@import "@/assets/stylesheet/variables.scss";`
            }
        }
    }
}
```

**问题**：options has an unknown property 'additionalData'，解决也简单，这段报错的后面紧跟着These properties are valid:  object { implementation?, sassOptions?, prependData?, sourceMap?, webpackImporter? }，选中其中的一项。

2. v-for里v-modal绑定动态数据

   ```javascript
   this.form.map(item => {
       
           // this.formData[item.key] = item.value
           // this.rules[item.key] = item.rule
       
           // 在初始化的时候，会生成属性的getter、setter。通过setter函数的调用，从而触发组件更新。而直接赋值，并没有setter函数的触发
           this.$set(this.formData, item.key, item.value)
           this.$set(this.rules, item.key, item.rule)
         })
   ```


### 路由警告

`[vue-router] Duplicate named routes definition: { name: "quotePrice", path: "/quotePrice" }`

一般这个警告是因为路由里的name值有重复的。解决name重复即可。

### css 穿透警告

`/deep/ combinator is no longer supported in CSS dynamic profile. It is now effectively no-op, acting as if it were a descendant combinator. /deep/ combinator will be removed, and will be invalid at M65. You should remove it.`

可以根据警告意思看出 /deep/ 已经废弃掉了，我们可以用 `>>>`  来达到覆盖组件样式。

### i18n 警告

`[vue-i18n] Value of key '首页' is not a string!`

这是因为在语言环境信息中某个语言环境不存在`message`键：

```javascript
const messages = {
  en-US: {
    message: 'hello world'
  },
  cn: {
  }
}
```

而VueI18n 构造函数的 `fallbackLocale` 选项——回退本地化。如果没有指定的话，会默认是`en-US`，也就是：

```javascript
const i18n = new VueI18n({
  locale: 'cn',
  // fallbackLocale: 'en-US', 默认 en-US
  messages
})
```

那么此时模板里去使用：

```javascript
<p>{{ $t('message') }}</p>

// 显示
<p>hello world</p>
```

而默认情况下回退到 `fallbackLocale` 会产生警告：

`[vue-i18n] Value of key 'message' is not a string!`

为了避免这些警告 (同时保留那些完全没有翻译给定关键字的警告)，需初始化 `VueI18n` 实例时设置 `silentFallbackWarn：true`。

### 二级返回一级缓存搜索条件

> - 方案一：session
>
>    每个列表页面里都添加一个方法，用来在跳转详情页面的时候，缓存搜索条件到session或者 vuex里，从详情页面返回到列表页面时，从缓存里找到搜索条件，并刷新页面
>
> - 方案二：vuex
>
>     本质上还是写一个公用的方法，来在跳转页面的时候缓存页面的搜索条件。当跳转列表页面的触发此方法，将对应的搜索条件缓存在vuex中，从详情页面返回的时候，列表页面获取缓存的数据并请求数据。
>
> - 方案三：mixin
>
>     使用 mixin 混入来写一个公用的方法实现跳转缓存搜索条件，从而在返回时拿到缓存的数据，进行请求
>
> 总结：这几个方法综合起来使用，可以更快达到预期效果

首先，我们使用 mixin 来实现：

新建一个 query.js:

```javascript
export default{
  watch: {
    // 深度监听对象里的每个值的变化
    'searchParam': {
      handler() {
        // 缓存搜索条件及当前路由的name
        this.$store.commit('CACHE_QUERY', this.searchParam)
        this.$store.commit('CACHE_ROUTE_NAME', this.$route.name)
      },
      deep: true
    }
  },
  created() {
      // 强制更改 elementui 里的分页，不会触发current-change 方法，需要重置分页总数为 Null 后，重新渲染分页
      this.tableParam.total = null
  },
  mounted() {
    this.parseQuery()
  },
  methods: {
    parseQuery() {
      // 存一份初始值，当路由名称不一样时，刷新页面
      if (this.$store.state.app.currentRouteName !== this.$route.name) {
        this.$store.commit('CACHE_TAB_INDEX', 'my')
      } else {
        // 将缓存在 vuex 中的搜索条件，和当前的搜索条件合在一起
        let query = Object.assign({}, this.$store.state.app.searchQuery)
        this.searchParam = {...this.searchParam, ...query}
      }
      // 如果使用了 el-tabs，那在这里先获取存在 vuex 里的 activeName 值，并改变选中项
      this.$parent.$parent.$parent.activeName = this.$parent.$parent.$parent.activeName && this.$store.state.app.currentTabIndex
    }
  }
}
```

其次，在对应的 vuex 里去设置对应的字段用来缓存数据。

需要注意的是这里的 searchParam 在每个列表页面都有，它代表每个页面对应的搜索条件。

再在需要使用的 list 页面去使用：

```javascript
import queryList from '@/commons/mixins/query'

export default {
    mixins: [queryList]
}
```

如果要缓存 tab 对应的 activeName，那么在对应的点击事件里调用:

```javascript
this.$store.commit('CACHE_TAB_INDEX', this.activeName)
```

完成。

> 如果没有使用 el-tabs ，那么可以不要 activeName 相关的代码

### 关于el-select下拉框回显

问题场景，v-model绑定的是options里的value值，所以会发现我们将数据缓存，或者拿到后端返回的数据后，回显的也是value值，那么这里有一个问题就是如果value值是数字，而我们要展示的是label，就会出现回显错误的问题。

我的解决办法是：

1. 在选择完后，缓存选中的`key-value`对象；
2. 在需要回显的时候，先检验一下有没有咱们缓存的对象
3. 如果有，则将这个缓存的对象先赋值给options（这里应该是数组），然后把对应的options里的第0项的key值赋值给v-model
4. 如果没有，说明没有被选中过
5. 在mounted里去执行检验方法，确保每次页面加载后只执行一次
6. 在重置时，手动把这个对象重置为空对象

```javascript
// 先缓存
selectCompany(value) {
    // 这里的 options 是搜索出来后的
    const item = this.options.filter(item => item.value === value)
    this.searchParam.companyName = item[0]
},

// 缓存检验
checkCompanyName() {
    if (this.searchParam.companyName['value']) {
        this.options = [this.searchParam.companyName]
        this.searchParam.companyId = this.options[0]['value']
    }
},
```

