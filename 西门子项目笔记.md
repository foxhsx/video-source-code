## 西门子项目

1. router 里 import 报错

   ```javascript
   import Vue from 'vue'
   import Router from 'vue-router'
   
   Vue.use(Router)
   
   export default new Router({
     routes: [
       {
         path: '/',
         name: 'layout',
         component: () => import('@/layout/Index')
       }
     ]
   })
   ```

   如果没有安装`babel-plugin-syntax-dynamic-import`插件，并在`.babelrc`中引入此插件，那么就会报错。这是 webpack 动态导入模块的设置。

   ```sh
   {
     "presets": [["es2015", { "modules": false }]],
     "plugins": [
       [
         "component",
         {
           "libraryName": "element-ui",
           "styleLibraryName": "theme-chalk"
         }
       ],
       "syntax-dynamic-import"
     ]
   }
   ```

2. Module build failed: TypeError: this.getResolve is not a function

   ```javascript
   // 这是因为当前sass的版本太高，webpack编译时出现了错误，这个时候只需要换成低版本的就行
   // 卸载当前版本，并安装低版本的 sass-loader
   ```

3. 使用嵌套路由

   ```javascript
   // 一个被渲染组件同样可以包含自己的嵌套 <router-view>。例如，在 User 组件的模板添加一个 <router-view>
   const User = {
     template: `
       <div class="user">
         <h2>User {{ $route.params.id }}</h2>
         <router-view></router-view>
       </div>
     `
   }
   
   ```

   要在嵌套的出口中渲染组件，需要在 `VueRouter` 的参数中使用 `children` 配置:

   ```javascript
   const router = new VueRouter({
     routes: [
       { path: '/user/:id', component: User,
         children: [
           {
             // 当 /user/:id/profile 匹配成功，
             // UserProfile 会被渲染在 User 的 <router-view> 中
             path: 'profile',
             component: UserProfile
           },
           {
             // 当 /user/:id/posts 匹配成功
             // UserPosts 会被渲染在 User 的 <router-view> 中
             path: 'posts',
             component: UserPosts
           }
         ]
       }
     ]
   })
   ```

   **要注意，以 `/` 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。**

   4. 在新版的`vue-cli`中已经帮我们把`sass-loader`配置好了，放在了`util.js`里面，之前我们还需要去在`webpack.base.config.js`中去配置相关的设置，现在只需要安装相应的`loader`即可。如果还在webpack.base.config.js中去配置，只会重复配置`sass-loader`，从而导致报错：this dependency was not found
   
   5. 在vue中要使用自适应尺寸，可以使用`viewportWidth`插件，从配置上比`rem`布局简洁了很多，在脚手架生成的模板里找到`.postcssrc.js`文件，这个文件是vue生成的关于postCSS的配置文件，在这里面我们可以对自适应尺寸进行相关的配置。
   
      ```javascript
      // 首先下载安装PostCss插件
      npm install postcss-px-to-viewport -D
      // 或者
      yarn add postcss-px-to-viewport -D
      
      // 然后在 .postcssrc.js 中去配置
      // https://github.com/michael-ciniawsky/postcss-load-config
      
      // 配置 PC 端
      module.exports = {
        "plugins": {
          "postcss-import": {},
          "postcss-url": {},
          // to edit target browsers: use "browserslist" field in package.json
          "autoprefixer": {},
          "postcss-px-to-viewport": {
            unitToConvert: "px",	// 需要转换的单位，默认为"px"
            viewportWidth: 1920,   // 视窗的宽度，对应pc设计稿的宽度，一般是1920
            // viewportHeight: 1080,// 视窗的高度，对应的是我们设计稿的高度
            unitPrecision: 3,		// 单位转换后保留的精度
            propList: [		// 能转化为vw的属性列表
              "*"
            ],
            viewportUnit: "vw",		// 希望使用的视口单位
            fontViewportUnit: "vw",		// 字体使用的视口单位
            selectorBlackList: [],	// 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。
            minPixelValue: 1,		// 设置最小的转换数值，如果为1的话，只有大于1的值会被转换
            mediaQuery: false,		// 媒体查询里的单位是否需要转换单位
            replace: true,		// 是否直接更换属性值，而不添加备用属性
            // exclude: /(\/|\\)(node_modules)(\/|\\)/,		// 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
          }
        }
      }
      
      // 移动端
      module.exports = {
        "plugins": {
          "postcss-import": {},
          "postcss-url": {},
          // to edit target browsers: use "browserslist" field in package.json
          "autoprefixer": {},
          "postcss-px-to-viewport": {
            unitToConvert: "px",	// 需要转换的单位，默认为"px"
            viewportWidth: 375,   // 视窗的宽度，对应移动端设计稿的宽度，一般是375
            // viewportHeight:667,// 视窗的高度，对应的是我们设计稿的高度
              unitPrecision: 3,		// 单位转换后保留的精度
              propList: [		// 能转化为vw的属性列表
                  "*"
            ],
            viewportUnit: "vw",		// 希望使用的视口单位
            fontViewportUnit: "vw",		// 字体使用的视口单位
            selectorBlackList: [],	// 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。
            minPixelValue: 1,		// 设置最小的转换数值，如果为1的话，只有大于1的值会被转换
            mediaQuery: false,		// 媒体查询里的单位是否需要转换单位
            replace: true,		// 是否直接更换属性值，而不添加备用属性
            exclude: /(\/|\\)(node_modules)(\/|\\)/		// 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
          }
        }
      }
      ```
   
   6. 在`elementUI`中，给`el-row`、`el-col`等组件添加`click`事件时失效，这时我们需要这样写。
   
      ```javascript
      // .native 绑定原生事件
      <el-col :span="10" class="cart" @click.native="handleCart">
      ```
   
   7. 在vue中动态定义图片路径报错
   
      当图片地址是写在模板里的话，webpack中的 url-loader 会处理图片的最终地址，最终小体积图片会被编译成 base64 ，而大体积的图片则会是绝对地址。
      当 Vue.js 来动态定义图片路径的时候，url-loader 是无法探测到图片路径的。这样的话在 build 后，我们可以看到图片没有被打包输出到 dist 目录里。
      那么这个时候我们有以下三种解决方法：
      1. 绝对路径访问
        把图片放到静态资源目录static目录下（build 会将static目录中的文件或者文件夹按照原本的结构放在dist目录下），并用/static绝对路径访问：
   
        ```javascript
        <template>
            <div>
                <img :src="src" alt="图片" />
            </div>
        </template>
        <script>
            export default{
                data(){
                  return {
                      src:`/static/img/user.png`
                  }
                }
            }
        </script>
        ```
   
      2. 使用 require
   
        如果想在不调整目录结构的情况下读取图片，还可以使用require：
   
        ```javascript
        data(){
             return {
                 src:require('../assets/user.png')
            }
        }
        ```
   
      3. 使用 import
   
        也可以用import引入图片路径：
   
        ```javascript
        <template>
            <div>
                <img :src="src" alt="图片" />
            </div>
        </template>
        <script>
            import userPath from '../assets/user.png'
            export default{
                data(){
                  return {
                      src:userPath 
                  }
                }
            }
        </script>
        ```
   
   8. vue 监听 $route
   
      ```javascript
      // 接着在父组件内
      // watch $route 决定使用哪种过渡
      watch: {
        '$route' (to, from) {
          const toDepth = to.path.split('/').length
          const fromDepth = from.path.split('/').length
          this.transitionName = toDepth < fromDepth ? 'slide-right' : 'slide-left'
        }
      }
      ```
   
   9. Error: Cannot find module ‘webpack/lib/RequestShortener’
   
      删掉了**package-lock.json**和**node_modules**后，再全局npm install，然后就成功了
   
   10. vue/cli3.0 启动项目后报错，**[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build**
   
       ![img](https://images2018.cnblogs.com/blog/1378694/201808/1378694-20180803202905015-408708499.png)
   
       ```javascript
       
       ```
   
       这里引用的是vue.runtime.esm.js，造成的不能正常运行，查看cli2X的版本，在webpack.base.conf.js配置文件中多加了一段代码: resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' }，意思就是说咱们在 3.0 版本中的 vue.config.js 中也得加这么一段代码防止其编译后报错
   
   11. **Warning: start value has mixed support, consider using flex-start instead**
   
       ```
       由于 css 书写不规范而导致的
       .flex {
       	display: flex;
           align-items: center;
           justify-content: start;
       }
       
       修改规范后，警告消失
       .flex {
       	display: flex;
           align-items: center;
           justify-content: flex-start;
       }
       ```
   
   12. 