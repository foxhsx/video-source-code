## 西门子项目

1. router 里 import 报错

   ```javascript
   import Vue from 'vue'
   import Router from 'vue-router'
   
   Vue.use(Router)
   
   export default new Router({
     routes: [
       {
         path: '/',
         name: 'layout',
         component: () => import('@/layout/Index')
       }
     ]
   })
   ```

   如果没有安装`babel-plugin-syntax-dynamic-import`插件，并在`.babelrc`中引入此插件，那么就会报错。这是 webpack 动态导入模块的设置。

   ```sh
   {
     "presets": [["es2015", { "modules": false }]],
     "plugins": [
       [
         "component",
         {
           "libraryName": "element-ui",
           "styleLibraryName": "theme-chalk"
         }
       ],
       "syntax-dynamic-import"
     ]
   }
   ```

2. Module build failed: TypeError: this.getResolve is not a function

   ```javascript
   // 这是因为当前sass的版本太高，webpack编译时出现了错误，这个时候只需要换成低版本的就行
   // 卸载当前版本，并安装低版本的 sass-loader
   ```

3. 使用嵌套路由

   ```javascript
   // 一个被渲染组件同样可以包含自己的嵌套 <router-view>。例如，在 User 组件的模板添加一个 <router-view>
   const User = {
     template: `
       <div class="user">
         <h2>User {{ $route.params.id }}</h2>
         <router-view></router-view>
       </div>
     `
   }
   
   ```

   要在嵌套的出口中渲染组件，需要在 `VueRouter` 的参数中使用 `children` 配置:

   ```javascript
   const router = new VueRouter({
     routes: [
       { path: '/user/:id', component: User,
         children: [
           {
             // 当 /user/:id/profile 匹配成功，
             // UserProfile 会被渲染在 User 的 <router-view> 中
             path: 'profile',
             component: UserProfile
           },
           {
             // 当 /user/:id/posts 匹配成功
             // UserPosts 会被渲染在 User 的 <router-view> 中
             path: 'posts',
             component: UserPosts
           }
         ]
       }
     ]
   })
   ```

   **要注意，以 `/` 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。**

   4. 在新版的`vue-cli`中已经帮我们把`sass-loader`配置好了，放在了`util.js`里面，之前我们还需要去在`webpack.base.config.js`中去配置相关的设置，现在只需要安装相应的`loader`即可。如果还在webpack.base.config.js中去配置，只会重复配置`sass-loader`，从而导致报错：this dependency was not found
   
   5. 在vue中要使用自适应尺寸，可以使用`viewportWidth`插件，从配置上比`rem`布局简洁了很多，在脚手架生成的模板里找到`.postcssrc.js`文件，这个文件是vue生成的关于postCSS的配置文件，在这里面我们可以对自适应尺寸进行相关的配置。
   
      ```javascript
      // 首先下载安装PostCss插件
      npm install postcss-px-to-viewport -D
      // 或者
      yarn add postcss-px-to-viewport -D
      
      // 然后在 .postcssrc.js 中去配置
      // https://github.com/michael-ciniawsky/postcss-load-config
      
      // 配置 PC 端
      module.exports = {
        "plugins": {
          "postcss-import": {},
          "postcss-url": {},
          // to edit target browsers: use "browserslist" field in package.json
          "autoprefixer": {},
          "postcss-px-to-viewport": {
            unitToConvert: "px",	// 需要转换的单位，默认为"px"
            viewportWidth: 1920,   // 视窗的宽度，对应pc设计稿的宽度，一般是1920
            // viewportHeight: 1080,// 视窗的高度，对应的是我们设计稿的高度
            unitPrecision: 3,		// 单位转换后保留的精度
            propList: [		// 能转化为vw的属性列表
              "*"
            ],
            viewportUnit: "vw",		// 希望使用的视口单位
            fontViewportUnit: "vw",		// 字体使用的视口单位
            selectorBlackList: [],	// 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。
            minPixelValue: 1,		// 设置最小的转换数值，如果为1的话，只有大于1的值会被转换
            mediaQuery: false,		// 媒体查询里的单位是否需要转换单位
            replace: true,		// 是否直接更换属性值，而不添加备用属性
            // exclude: /(\/|\\)(node_modules)(\/|\\)/,		// 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
          }
        }
      }
      
      // 移动端
      module.exports = {
        "plugins": {
          "postcss-import": {},
          "postcss-url": {},
          // to edit target browsers: use "browserslist" field in package.json
          "autoprefixer": {},
          "postcss-px-to-viewport": {
            unitToConvert: "px",	// 需要转换的单位，默认为"px"
            viewportWidth: 375,   // 视窗的宽度，对应移动端设计稿的宽度，一般是375
            // viewportHeight:667,// 视窗的高度，对应的是我们设计稿的高度
              unitPrecision: 3,		// 单位转换后保留的精度
              propList: [		// 能转化为vw的属性列表
                  "*"
            ],
            viewportUnit: "vw",		// 希望使用的视口单位
            fontViewportUnit: "vw",		// 字体使用的视口单位
            selectorBlackList: [],	// 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。
            minPixelValue: 1,		// 设置最小的转换数值，如果为1的话，只有大于1的值会被转换
            mediaQuery: false,		// 媒体查询里的单位是否需要转换单位
            replace: true,		// 是否直接更换属性值，而不添加备用属性
            exclude: /(\/|\\)(node_modules)(\/|\\)/		// 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
          }
        }
      }
      ```
   
   6. 在`elementUI`中，给`el-row`、`el-col`等组件添加`click`事件时失效，这时我们需要这样写。
   
      ```javascript
      // .native 绑定原生事件
      <el-col :span="10" class="cart" @click.native="handleCart">
      ```
   
   7. 在vue中动态定义图片路径报错
   
      当图片地址是写在模板里的话，webpack中的 url-loader 会处理图片的最终地址，最终小体积图片会被编译成 base64 ，而大体积的图片则会是绝对地址。
      当 Vue.js 来动态定义图片路径的时候，url-loader 是无法探测到图片路径的。这样的话在 build 后，我们可以看到图片没有被打包输出到 dist 目录里。
      那么这个时候我们有以下三种解决方法：
      1. 绝对路径访问
          把图片放到静态资源目录static目录下（build 会将static目录中的文件或者文件夹按照原本的结构放在dist目录下），并用/static绝对路径访问：
   
        ```javascript
        <template>
            <div>
                <img :src="src" alt="图片" />
            </div>
        </template>
        <script>
            export default{
                data(){
                  return {
                      src:`/static/img/user.png`
                  }
                }
            }
        </script>
        ```
   
      2. 使用 require
   
        如果想在不调整目录结构的情况下读取图片，还可以使用require：
   
        ```javascript
        data(){
             return {
                 src:require('../assets/user.png')
            }
        }
        ```
   
      3. 使用 import
   
        也可以用import引入图片路径：
   
        ```javascript
        <template>
            <div>
                <img :src="src" alt="图片" />
            </div>
        </template>
        <script>
            import userPath from '../assets/user.png'
            export default{
                data(){
                  return {
                      src:userPath 
                  }
                }
            }
        </script>
        ```
   
   8. vue 监听 $route
   
      ```javascript
      // 接着在父组件内
      // watch $route 决定使用哪种过渡
      watch: {
        '$route' (to, from) {
          const toDepth = to.path.split('/').length
          const fromDepth = from.path.split('/').length
          this.transitionName = toDepth < fromDepth ? 'slide-right' : 'slide-left'
        }
      }
      ```
   
   9. Error: Cannot find module ‘webpack/lib/RequestShortener’
   
      删掉了**package-lock.json**和**node_modules**后，再全局npm install，然后就成功了
   
   10. vue/cli3.0 启动项目后报错，**[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build**
   
       ![img](https://images2018.cnblogs.com/blog/1378694/201808/1378694-20180803202905015-408708499.png)
   
       ```javascript
       
       ```
   
       这里引用的是vue.runtime.esm.js，造成的不能正常运行，查看cli2X的版本，在webpack.base.conf.js配置文件中多加了一段代码: resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' }，意思就是说咱们在 3.0 版本中的 vue.config.js 中也得加这么一段代码防止其编译后报错
   
   11. **Warning: start value has mixed support, consider using flex-start instead**
   
       ```
       由于 css 书写不规范而导致的
       .flex {
       	display: flex;
           align-items: center;
           justify-content: start;
       }
       
       修改规范后，警告消失
       .flex {
       	display: flex;
           align-items: center;
           justify-content: flex-start;
       }
       ```
   
   12. el-input placeholder 颜色
   
       ```javascript
       .el-input__inner {
           &::placeholder {
               color: #fff;
           }
       
           &::-webkit-input-placeholder {
               /* WebKit browsers 适配谷歌 */
               color: #fff;
           }
       
           &:-moz-placeholder {
               /* Mozilla Firefox 4 to 18 适配火狐 */
               color: #fff;
           }
       
           &::-moz-placeholder {
               /* Mozilla Firefox 19+ 适配火狐 */
               color: #fff;
           }
       
           &:-ms-input-placeholder {
               /* Internet Explorer 10+  适配ie*/
               color: #fff;
           }
       }
       ```
   
   13. axios 跨域设置
   
       在 vue.config.js 中：
   
       ```javascript
       devServer: {
           proxy: {
               '/api': {
               target: 'http://127.0.0.1:8100/', //对应自己的接口
               changeOrigin: true,
               ws: true,
               pathRewrite: {
                 '^/api': ''
               }
             }
           }
       }
       ```
   
       配置完成后，重启项目。
   
       然后配置 axios 请求的 baseUrl:
   
       ```javascript
       axios.defaults.baseUrl = '/api'   // 这里的 /api 即上面 vue.config.js 中配置的地址
       ```
   
       如果 axios 的 baseUrl 直接写请求地址的话，请求不会经过 proxy 的代理，请求就直接发出去了。后台如果已经配置了 `Access-Control-Allow-Origin: *`的话，那么就不会出现跨域问题，否则跨域请求就会被浏览器拦截了。
   
       而如果 baseUrl  采用的是 `/api` 的方式的话，就会直接匹配到 proxy，从而代理到 target 指向的 url。
   
       pathRewrite 这个配置项的作用是来替换 url 中的某些字符串，保证代理之后的 url 是正确的。
   
       ```javascript
       pathRewrite: {
         '^/api': ''
       }
       ```
   
       这里 `^` 是正则，是以 `api` 开头的意思。
   
       我们还可以再加一个字段：
   
       ```javascript
       {
           logLevel: 'debug'
       }
       ```
   
       这样的话就会把每次请求的代理过程在命令行中输出出来.
   
   14. 不同环境的 baseurl 设置
   
       首先根据 `process.env.NODE_ENV ` 来判断环境变量，并存起来
   
       ```javascript
       const ENV = process.env.NODE_ENV 
       
       // 使用三元表达式来实现 baseUrl 的动态切换
       axios.defaults.baseURL = ENV === 'development' ? '/frame-boot-control': '生产环境路径'
       ```
   
   15. 配置UAT环境
   
       在 package.json 文件同目录下，新建 .env.uat 文件：
   
       - NODE_ENV 变量为 uat ，修改变量：VUE_APP_CURRENTMODE 变量为 uat
   
       ```sh
       NODE_ENV = 'uat'
       VUE_APP_CURRENTMODE = 'uat'
       ```
   
       - 在 package.json 中的 scripts 新增 uat 命令：
         - ‘build:uat’: "vue-cli-service build --mode uat"
   
   16. IE 兼容性
   
       后台项目打包发版后，在 Edge 浏览器和IE浏览器翻页失效，是因为：
   
       ```javascript
       var requestAnimFrame = (function() {
         return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) { window.setTimeout(callback, 1000 / 60) }
       })()
       
       /**
        * @param {number} to
        * @param {number} duration
        * @param {Function} callback
        */
       export function scrollTo(to, duration, callback) {
         const start = position()
         const change = to - start
         const increment = 20
         let currentTime = 0
         duration = (typeof (duration) === 'undefined') ? 500 : duration
         var animateScroll = function() {
           // increment the time
           currentTime += increment
           // find the value with the quadratic in-out easing function
           var val = Math.easeInOutQuad(currentTime, start, change, duration)
           // move the document.body
           move(val)
           // do the animation unless its over
           if (currentTime < duration) {
             requestAnimFrame(animateScroll)
           } else {
             if (callback && typeof (callback) === 'function') {
               // the animation is done so lets callback
               callback()
             }
           }
         }
         animateScroll()
       }
       ```
   
       这段代码在 Edge 浏览器下的时候，`requestAnimFrame` 返回的是一个函数：
   
       ```javascript
       function requestAnimationFrame () {}
       ```
   
       而不是 `window.requestAnimationFrame`，而正是因为这个原因导致在 edge 浏览器下报错——`调用的对象无效`。
   
       那么处理方法也很简单，我们在`requestAnimFrame` 函数里这样去修改：
   
       ```javascript
       var requestAnimFrame = (function() {
         return window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame.bind(window) || function(callback) { window.setTimeout(callback, 1000 / 60) }
       })()
       ```
   
   17. 打包时，测试环境及其他环境打出来的包，项目体积会比生产环境大很多，